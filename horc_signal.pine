/@version=6
// =============================================================================
// HORC SIGNAL SYSTEM v4.1 - INTENT MEMORY ARCHITECTURE
// Market State Inference Engine with Temporal Force Persistence
// Generated: 2026-02-03
//
// BREAKTHROUGH IN v4.1 (Intent Memory Layer):
//   ✓ Intent Balance: Net unfulfilled market effort with slow decay
//   ✓ Stable Vector Anchoring: Defended liquidity (swept levels) not session mid
//   ✓ Real-Time Safe Absorption: No future bias, uses current intent state
//   ✓ Conditional CPS: Factors interact (not additive), intent-gated probability
//   ✓ Persistence > Recency: Intent lingers 50 bars (not 20), markets remember
//
// PREVIOUS PHASES:
//   ✓ Phase 1: Participant Engine (OR-based participant ID)
//   ✓ Phase 2: 7-State Wavelength FSM (deterministic cycle)
//   ✓ Phase 3: Vector Force Engine (direction × strength × persistence × effort)
//   ✓ Phase B: Explicit Regime Filters (block compressed, time-of-day)
//   ✓ Phase C: Failure Memory (zone rejection tracking, wavelength bias)
//   ✓ Phase D: Intent Memory (temporal force accumulation, alignment gating)
//
// PHASES IMPLEMENTED:
//   ✓ PHASE 1: Participant Engine (WHO is in control) - OR-based
//   ✓ PHASE 1.5: Flip + Charge + Coordinate (WHEN, +/−, STATE)
//   ✓ PHASE 1.75: Divergence + Absorption + AOI (PASSIVE VS AGGRESSOR)
//   ✓ PHASE 2: Liquidity Registration (ZONE TARGETING)
//   ✓ PHASE 3: Vector Force Engine (MAGNITUDE, ENERGY, DECAY)
//
// AXIOMS (FULL COMPLIANCE):
//   - AXIOM 1: Wavelength Invariant (7-state FSM, 3-move cycle)
//   - AXIOM 2: First Move Determinism (OR sweep participant ID)
//   - AXIOM 3: Absorption Reversal (energy-weighted exhaustion)
//   - AXIOM 4: Futures Supremacy (session-based gap targeting)
//
// ARCHITECTURAL SHIFT:
//   From: Binary polarity (+1/-1 labels)
//   To: Continuous force vectors (magnitude = direction × strength × recency × effort)
//   Impact: Divergence becomes measurable energy imbalance, not symbolic opposition
// =============================================================================

indicator("HORC Signal System v4.2.2", overlay=true, max_bars_back=5000, max_lines_count=100, max_boxes_count=50)

// =============================================================================
// INPUT PARAMETERS
// =============================================================================

// Opening Range (AXIOM 2)
or_window_minutes = input.int(30, "OR Window (minutes)", options=[15, 30, 60], group="Opening Range")
or_session_start = input.session("0930-1600", "Session Times (use '24H' for crypto/forex)", group="Opening Range")
use_24h_mode = input.bool(false, "Enable 24-Hour Mode (Crypto/Forex)", group="Opening Range")

// Wavelength Settings (AXIOM 1)
min_move_atr = input.float(0.3, "Min Move (ATR multiplier)", minval=0.1, maxval=5.0, step=0.1, group="Wavelength")
max_retracement = input.float(0.786, "Max Retracement", minval=0.382, maxval=0.886, step=0.05, group="Wavelength")

// Exhaustion Weights (AXIOM 3 - MUST SUM TO 1.0)
vol_weight = input.float(0.30, "Volume Weight", minval=0.0, maxval=1.0, step=0.05, group="Exhaustion")
body_weight = input.float(0.30, "Body Weight", minval=0.0, maxval=1.0, step=0.05, group="Exhaustion")
price_weight = input.float(0.25, "Price Stagnation Weight", minval=0.0, maxval=1.0, step=0.05, group="Exhaustion")
rev_weight = input.float(0.15, "Reversal Weight", minval=0.0, maxval=1.0, step=0.05, group="Exhaustion")
exhaustion_threshold = input.float(0.70, "Exhaustion Threshold", minval=0.5, maxval=1.0, step=0.05, group="Exhaustion")

// Confluence Weights (CPS V2)
participant_weight = input.float(0.35, "Participant Weight", minval=0.0, maxval=1.0, step=0.05, group="Confluence")
wavelength_weight = input.float(0.30, "Wavelength Weight", minval=0.0, maxval=1.0, step=0.05, group="Confluence")
exhaustion_weight = input.float(0.25, "Exhaustion Weight", minval=0.0, maxval=1.0, step=0.05, group="Confluence")
gap_weight = input.float(0.10, "Gap Weight", minval=0.0, maxval=1.0, step=0.05, group="Confluence")
confluence_threshold = input.float(0.50, "CPS Threshold", minval=0.0, maxval=1.0, step=0.05, group="Confluence")

// Futures Gaps (AXIOM 4)
gap_min_points = input.float(2.0, "Min Gap (points)", minval=0.5, maxval=10.0, step=0.5, group="Gaps")
gap_max_age = input.int(50, "Max Gap Age (bars)", minval=10, maxval=200, step=10, group="Gaps")

// Display Settings
show_or_box = input.bool(true, "Show OR Box", group="Display")
show_signals = input.bool(true, "Show Signals", group="Display")
show_wavelength = input.bool(true, "Show Wavelength Pattern", group="Display")
show_coordinates = input.bool(true, "Show Coordinates", group="Display")
show_divergence = input.bool(true, "Show Divergence", group="Display")
show_table = input.bool(true, "Show Info Table", group="Display")

// Signal History & Accuracy Tracking
show_signal_history = input.bool(true, "Show Signal History", group="Signal Tracking")
lookback_period = input.int(50, "Lookback Period (signals)", minval=10, maxval=500, step=10, group="Signal Tracking")
show_accuracy_table = input.bool(true, "Show Accuracy Table", group="Signal Tracking")
outcome_bars = input.int(20, "Bars to Determine Outcome", minval=5, maxval=100, step=5, group="Signal Tracking")
show_all_history = input.bool(false, "Show ALL Historical Signals (may be slow)", group="Signal Tracking")
history_bars_visible = input.int(200, "Bars of History to Display", minval=50, maxval=1000, step=50, group="Signal Tracking")

// Alert Settings
enable_alerts = input.bool(true, "Enable Alerts", group="Alerts")

// Phase B: Regime Filters
block_compressed_regime = input.bool(true, "Block Trades in Compressed Regime", group="Regime")
compressed_threshold = input.float(0.70, "Compressed Volatility Threshold", minval=0.5, maxval=0.9, step=0.05, group="Regime")
expansion_threshold = input.float(1.30, "Expansion Volatility Threshold", minval=1.1, maxval=2.0, step=0.05, group="Regime")
enable_time_filters = input.bool(true, "Enable Time-of-Day Filters", group="Regime")
avoid_open_minutes = input.int(15, "Avoid First N Minutes", minval=0, maxval=60, step=5, group="Regime")
avoid_close_minutes = input.int(30, "Avoid Last N Minutes", minval=0, maxval=60, step=15, group="Regime")

// Phase C: State Persistence
enable_failure_memory = input.bool(true, "Enable Failure Memory", group="Memory")
failure_penalty = input.float(0.65, "CPS Penalty Near Failed Zones", minval=0.3, maxval=0.9, step=0.05, group="Memory")
failure_decay_bars = input.int(100, "Failure Memory Decay (bars)", minval=20, maxval=300, step=20, group="Memory")
max_failures_tracked = input.int(10, "Max Failed Zones Tracked", minval=5, maxval=30, step=5, group="Memory")

// Phase D: Intent Memory (v4.1)
enable_intent_memory = input.bool(true, "Enable Intent Memory Layer", group="Intent")
intent_aggressor_weight = input.float(0.60, "Aggressor Intent Weight", minval=0.0, maxval=1.0, step=0.05, group="Intent")
intent_passive_weight = input.float(0.40, "Passive Intent Weight", minval=0.0, maxval=1.0, step=0.05, group="Intent")
intent_decay = input.float(0.995, "Intent Decay Rate", minval=0.98, maxval=0.999, step=0.001, group="Intent")
intent_flip_threshold = input.float(0.20, "Intent Flip Threshold", minval=0.1, maxval=0.5, step=0.05, group="Intent")

// Phase E: HTF Directional Gating (v4.2)
enable_htf_gating = input.bool(true, "Enable HTF Directional Gating", group="HTF")
min_htf_alignment = input.int(2, "Minimum Timeframe Alignment", minval=1, maxval=4, step=1, group="HTF", tooltip="Require N timeframes to align (Session always counts)")
enable_structural_resets = input.bool(true, "Enable Structural Intent Resets", group="HTF")

// =============================================================================
// CONSTANTS
// =============================================================================

// Participant Types
const int BUYER = 1
const int SELLER = -1
const int INCONCLUSIVE = 0

// Wavelength States (AXIOM 1 - 7-state FSM)
const string STATE_PRE_OR = "PRE_OR"
const string STATE_PART_ID = "PART_ID"
const string STATE_MOVE_1 = "MOVE_1"
const string STATE_MOVE_2 = "MOVE_2"
const string STATE_FLIP_CONF = "FLIP_CONF"
const string STATE_MOVE_3 = "MOVE_3"
const string STATE_COMPLETE = "COMPLETE"
const string STATE_FAILED = "FAILED"

// Divergence Types
const int DIV_NONE = 0
const int DIV_PARTIAL = 1
const int DIV_FULL = 2

// Absorption Types
const int ABS_NONE = 0
const int ABS_INTERNAL = 1
const int ABS_EXTERNAL = 2
const int ABS_EXHAUSTION = 3

// Zone Status
const int ZONE_ACTIVE = 1
const int ZONE_MITIGATED = 2

// =============================================================================
// STATE VARIABLES
// =============================================================================

// Opening Range (AXIOM 2)
var float orh = na  // Opening Range High
var float orl = na  // Opening Range Low
var float orm = na  // Opening Range Mid
var int or_start_bar = na
var int or_end_bar = na
var bool or_formed = false

// Participant State (AXIOM 2)
var int current_participant = INCONCLUSIVE
var bool conviction = false  // True if sweep on first candle after OR
var int sweep_bar = na

// Wavelength State Machine (AXIOM 1)
var string w_state = STATE_PRE_OR
var int moves_completed = 0
var float move_1_extreme = na
var float move_2_extreme = na  // Becomes flip point
var float flip_point = na
var int flip_bar_idx = na

// Vector Coordinate State (V4.0 - Force-Based Architecture)
// Each coordinate is now a vector with magnitude = direction × strength × recency × effort
var float vec_D_passive = na       // Passive vector magnitude
var float vec_D_passive_base = na  // Baseline price for passive
var int vec_D_passive_age = na     // Age in bars

var float vec_D_aggressor = na      // Aggressor vector magnitude  
var float vec_D_aggressor_base = na // Baseline price for aggressor
var int vec_D_aggressor_age = na    // Age in bars

var float vec_S_passive = na
var float vec_S_aggressor = na

// Legacy compatibility (derived from vectors)
var int coord_M = na
var int coord_W = na
var int coord_D = na
var int coord_S = na

// Divergence tracking
var int divergence_type = DIV_NONE
var float divergence_score = 0.0
var int divergence_axes = 0  // How many axes diverge (0-4)

// Absorption tracking (AXIOM 3)
var int absorption_type = ABS_NONE
var float absorption_strength = 0.0
var float exhaustion_score = 0.0
var bool exhaustion_detected = false

// Swing tracking for AOI-aware divergence (V4.0 Vector-Enhanced)
var array<float> swing_prices = array.new<float>(0)
var array<int> swing_owners = array.new<int>(0)     // BUYER or SELLER who formed swing
var array<int> swing_bars = array.new<int>(0)
var array<string> swing_types = array.new<string>(0) // "HIGH" or "LOW"
var array<bool> swing_mitigated = array.new<bool>(0)
var array<float> swing_volumes = array.new<float>(0) // Volume at swing formation
var array<float> swing_magnitudes = array.new<float>(0) // Swing strength (ATR-normalized)

// Futures Gaps (AXIOM 4)
var array<float> gap_prices = array.new<float>(0)
var array<int> gap_bars = array.new<int>(0)
var array<bool> gap_filled = array.new<bool>(0)

// Liquidity zones
var array<float> zone_prices = array.new<float>(0)
var array<int> zone_types = array.new<int>(0)
var array<int> zone_status = array.new<int>(0)

// Signal state
var int signal_direction = INCONCLUSIVE
var float signal_confidence = 0.0
var float entry_price = na
var float stop_price = na
var float target_price = na

// Signal History Tracking
var array<int> hist_signal_bars = array.new<int>(0)          // Bar index of signal
var array<int> hist_signal_dirs = array.new<int>(0)          // BUYER or SELLER
var array<float> hist_entry_prices = array.new<float>(0)     // Entry price
var array<float> hist_stop_prices = array.new<float>(0)      // Stop price
var array<float> hist_target_prices = array.new<float>(0)    // Target price
var array<int> hist_outcomes = array.new<int>(0)             // 0=pending, 1=win, -1=loss, 2=breakeven
var array<float> hist_cps_scores = array.new<float>(0)       // CPS at signal time
var array<float> hist_rr_ratios = array.new<float>(0)        // Realized R:R ratio

// Performance metrics
var int total_signals = 0
var int total_wins = 0
var int total_losses = 0
var int total_breakeven = 0
var float total_rr = 0.0

// Regime Detection (V4.0 - Silent Adaptation)
var float regime_volatility = 1.0    // ATR percentile (0.5 = compressed, 1.5 = expanding)
var float regime_confidence_mult = 1.0 // Dynamic CPS adjustment
var float regime_exhaustion_mult = 1.0 // Dynamic exhaustion threshold
var string regime_state = "NORMAL"   // COMPRESSED, NORMAL, EXPANSION
var bool regime_tradeable = true     // Phase B: explicit trading permission

// Phase C: Failure Memory & State Persistence
var array<float> failed_flip_prices = array.new<float>(0)  // Prices where flips failed
var array<int> failed_flip_bars = array.new<int>(0)        // Bar indices of failures
var array<int> failed_flip_count = array.new<int>(0)       // Repeat failure count at zone
var array<int> failed_participant = array.new<int>(0)      // Which participant failed
var int session_failure_count = 0                           // Failures this session
var float wavelength_bias = 0.0                             // Accumulated bias from failures

// Phase D: Intent Memory Layer (v4.1 - Temporal Force Persistence)
var float intent_balance = 0.0        // Net unfulfilled market intent
var float intent_magnitude = 0.0      // Absolute intent pressure
var int intent_bars_held = 0          // How long current intent persists
var float defended_liquidity = na     // True defended price (not ORM)

// Phase E: HTF Directional Coordinates (v4.2 - Authority Hierarchy)
// Higher timeframes provide PERMISSION, not force
var int htf_M_direction = INCONCLUSIVE  // Monthly directional bias
var int htf_W_direction = INCONCLUSIVE  // Weekly directional bias
var int coord_alignment = 0             // How many timeframes align (1-4)
var bool htf_permission = true          // HTF gate for signals

// =============================================================================
// HELPER FUNCTIONS
// =============================================================================

// Calculate ATR and regime metrics (V4.0)
atr_14 = ta.atr(14)
avg_volume = ta.sma(volume, 10)

// Regime Detection - Volatility Percentile (silent adaptation)
atr_50 = ta.atr(50)
volatility_ratio = atr_50 > 0 ? atr_14 / atr_50 : 1.0
regime_volatility := volatility_ratio  // <0.7 = compressed, >1.3 = expanding

// Intent Memory Layer - Update each bar (v4.1)
if enable_intent_memory and not na(vec_D_aggressor) and not na(vec_D_passive)
    // Accumulate unfulfilled intent
    intent_balance += vec_D_aggressor * intent_aggressor_weight
    intent_balance -= vec_D_passive * intent_passive_weight
    
    // Slow decay (not exponential drop-off)
    intent_balance *= intent_decay  // 0.995 = very slow decay
    
    // v4.2.1: Soft saturation to prevent runaway bias
    intent_balance := math.tanh(intent_balance / 3.0) * 3.0
    
    // Track magnitude and persistence
    intent_magnitude := math.abs(intent_balance)
    
    // Count bars intent held in same direction
    if (intent_balance > 0 and intent_balance[1] > 0) or (intent_balance < 0 and intent_balance[1] < 0)
        intent_bars_held += 1
    else
        intent_bars_held := 0  // Reset on flip

// Phase E: Structural Intent Resets (v4.2 - Event-Driven, Not Time-Based)
if enable_structural_resets and enable_intent_memory
    bool structural_reset = false
    
    // Reset Event 1: Opening Range Expansion Break
    // Price moves beyond OR with conviction
    if or_formed and not na(orh) and not na(orl)
        float or_range = orh - orl
        bool or_expansion = (high > orh + or_range * 0.5) or (low < orl - or_range * 0.5)
        if or_expansion and volume > avg_volume * 1.5
            structural_reset := true
    
    // Reset Event 2: Full Gap Fill with Acceptance
    // Gap is filled AND price accepts beyond it
    if array.size(gap_prices) > 0
        for i = 0 to array.size(gap_prices) - 1
            if not array.get(gap_filled, i)
                gap_price = array.get(gap_prices, i)
                bars_since_gap = bar_index - array.get(gap_bars, i)
                if bars_since_gap >= 5 and bars_since_gap <= 10
                    // Recently filled - check acceptance
                    if math.abs(close - gap_price) > atr_14 * 2.0
                        structural_reset := true
                        break
    
    // Reset Event 3: Regime Transition
    // Volatility shifts dramatically
    bool regime_changed = (regime_state == "COMPRESSED" and regime_state[1] != "COMPRESSED") or
                         (regime_state == "EXPANSION" and regime_state[1] != "EXPANSION")
    if regime_changed
        structural_reset := true
    
    // Reset Event 4: HTF Sweep + Acceptance
    // Current participant changes AND HTF alignment breaks
    if enable_htf_gating
        bool participant_flipped = current_participant != current_participant[1] and 
                                  current_participant != INCONCLUSIVE
        bool htf_broke = coord_alignment < 2 and coord_alignment[1] >= 2
        if participant_flipped and htf_broke
            structural_reset := true
    
    // Execute structural reset
    if structural_reset
        intent_balance := 0.0
        intent_bars_held := 0
        intent_magnitude := 0.0

// Regime classification and adjustments (Phase B enhanced)
if regime_volatility < compressed_threshold
    // Compressed regime - reduce sensitivity or block trading
    regime_state := "COMPRESSED"
    regime_confidence_mult := 0.85
    regime_exhaustion_mult := 1.15
    regime_tradeable := not block_compressed_regime  // Phase B: explicit filter
else if regime_volatility > expansion_threshold
    // Expansion regime - increase sensitivity  
    regime_state := "EXPANSION"
    regime_confidence_mult := 1.15
    regime_exhaustion_mult := 0.90
    regime_tradeable := true
else
    // Normal regime
    regime_state := "NORMAL"
    regime_confidence_mult := 1.0
    regime_exhaustion_mult := 1.0
    regime_tradeable := true

// Phase E: HTF Directional Coordinate Extraction (v4.2)
// Extract DIRECTION ONLY from higher timeframes (no vectors)
if enable_htf_gating
    // Request participant direction from higher timeframes
    htf_M_direction := request.security(syminfo.tickerid, "M", current_participant, gaps=barmerge.gaps_off)
    htf_W_direction := request.security(syminfo.tickerid, "W", current_participant, gaps=barmerge.gaps_off)
    
    // Calculate coordinate alignment (permission scoring)
    coord_alignment := 0
    
    // Session always counts (it's the execution layer)
    coord_alignment += 1
    
    // Add HTF alignment
    if not na(htf_M_direction) and htf_M_direction == current_participant
        coord_alignment += 1
    if not na(htf_W_direction) and htf_W_direction == current_participant
        coord_alignment += 1
    if not na(coord_D) and coord_D == current_participant
        coord_alignment += 1
    
    // HTF permission gate (NOT a boost - a requirement)
    htf_permission := coord_alignment >= min_htf_alignment
else
    htf_permission := true  // Always allow if HTF gating disabled
    coord_alignment := 1    // Session only

// Time-of-day filter (Phase B)
bool time_tradeable = true
if enable_time_filters and not use_24h_mode
    if f_is_session_open() or f_is_session_close()
        time_tradeable := false

// Time-of-day detection (Phase B)
f_minutes_into_session() =>
    int mins = 0
    if not use_24h_mode and not na(or_start_bar)
        mins := bar_index - or_start_bar
    mins

f_is_session_open() =>
    mins = f_minutes_into_session()
    mins >= 0 and mins <= avoid_open_minutes

f_is_session_close() =>
    // Approximate - assumes ~390 minutes in trading day
    mins = f_minutes_into_session()
    session_length = 390  // NYSE standard
    mins >= (session_length - avoid_close_minutes)

// Check if near failed zone (Phase C)
f_near_failed_zone(price, tolerance_atr) =>
    bool near_failure = false
    float failure_bias = 0.0
    int repeat_failures = 0
    
    if enable_failure_memory and array.size(failed_flip_prices) > 0
        for i = 0 to array.size(failed_flip_prices) - 1
            failed_price = array.get(failed_flip_prices, i)
            failed_bar = array.get(failed_flip_bars, i)
            age = bar_index - failed_bar
            
            // Check proximity
            if math.abs(price - failed_price) < (atr_14 * tolerance_atr)
                // Apply decay to bias (older failures matter less)
                decay = math.exp(-age / failure_decay_bars)
                failure_bias += (1.0 - failure_penalty) * decay
                repeat_failures += array.get(failed_flip_count, i)
                near_failure := true
    
    [near_failure, failure_bias, repeat_failures]

// Session detection
is_new_session() =>
    // Check if 24-hour mode enabled
    if use_24h_mode
        ta.change(time("D")) != 0  // New day = new session
    else
        t = time(timeframe.period, or_session_start)
        not na(t) and (na(t[1]) or t > t[1])

in_session() =>
    // If 24-hour mode, always in session
    if use_24h_mode
        true
    else
        not na(time(timeframe.period, or_session_start))

minutes_since_or() =>
    // Approximate minutes elapsed since OR start
    bars_since = bar_index - or_start_bar
    bars_since  // Simplified: assumes 1-min bars

// Identify participant charge
f_calculate_charge(participant) =>
    int charge = na
    if participant == BUYER
        charge := 1
    else if participant == SELLER
        charge := -1
    charge

// Build coordinate (simplified - using daily timeframe)
f_build_coordinate(participant) =>
    int charge = f_calculate_charge(participant)
    charge

// Calculate divergence between two coordinates
f_calculate_divergence(passive_charge, aggressor_charge) =>
    int div_type = DIV_NONE
    float score = 0.0
    
    if not na(passive_charge) and not na(aggressor_charge)
        // Check for opposite signs (opposite participants)
        if passive_charge * aggressor_charge < 0
            div_type := DIV_FULL
            score := 1.0
        else
            div_type := DIV_NONE
            score := 0.0
    
    [div_type, score]

// Register liquidity zone
f_register_zone(price, participant_type) =>
    array.push(zone_prices, price)
    array.push(zone_types, participant_type)
    array.push(zone_status, ZONE_ACTIVE)

// Register failed flip zone (Phase C)
f_register_failed_flip(price, participant) =>
    // Check if zone already exists (increment counter)
    bool found = false
    if array.size(failed_flip_prices) > 0
        for i = 0 to array.size(failed_flip_prices) - 1
            existing_price = array.get(failed_flip_prices, i)
            if math.abs(existing_price - price) < atr_14 * 0.5
                // Same zone - increment failure count
                array.set(failed_flip_count, i, array.get(failed_flip_count, i) + 1)
                array.set(failed_flip_bars, i, bar_index)  // Update to recent
                found := true
                break
    
    if not found
        // New failed zone
        array.push(failed_flip_prices, price)
        array.push(failed_flip_bars, bar_index)
        array.push(failed_flip_count, 1)
        array.push(failed_participant, participant)
        
        // Cleanup old failures (keep last N)
        if array.size(failed_flip_prices) > max_failures_tracked
            array.shift(failed_flip_prices)
            array.shift(failed_flip_bars)
            array.shift(failed_flip_count)
            array.shift(failed_participant)
    
    // Accumulate wavelength bias
    wavelength_bias -= 0.2
    session_failure_count += 1

// Check if zone is mitigated
f_check_mitigation(zone_price, current_price, tolerance) =>
    bool mitigated = false
    if not na(zone_price) and not na(current_price)
        price_diff = math.abs(current_price - zone_price)
        threshold = zone_price * tolerance
        mitigated := price_diff <= threshold
    mitigated

// Calculate confluence score
f_calculate_confluence(participant_signal, wavelength_signal, exhaustion_signal, gap_signal) =>
    float score = 0.0
    score += participant_signal * participant_weight
    score += wavelength_signal * wavelength_weight
    score += exhaustion_signal * exhaustion_weight
    score += gap_signal * gap_weight
    score

// Swing detection for AOI tracking
f_is_swing_high(lookback) =>
    if bar_index < lookback * 2
        na
    else
        bool is_swing = true
        pivot_high = high[lookback]
        
        // Check left side
        for i = 1 to lookback
            if high[lookback + i] >= pivot_high
                is_swing := false
                break
        
        // Check right side
        if is_swing
            for i = 0 to lookback - 1
                if high[i] >= pivot_high
                    is_swing := false
                    break
        
        is_swing ? pivot_high : na

f_is_swing_low(lookback) =>
    if bar_index < lookback * 2
        na
    else
        bool is_swing = true
        pivot_low = low[lookback]
        
        // Check left side
        for i = 1 to lookback
            if low[lookback + i] <= pivot_low
                is_swing := false
                break
        
        // Check right side
        if is_swing
            for i = 0 to lookback - 1
                if low[i] <= pivot_low
                    is_swing := false
                    break
        
        is_swing ? pivot_low : na

// Build vector coordinate (V4.1 - Intent-Aware, Stable Anchoring)
// Returns: direction × strength × persistence × effort
f_build_vector_coordinate(participant, price, defended_price, age_bars, vol_ratio, is_passive) =>
    float vector = na
    
    if not na(participant) and not na(price) and not na(defended_price) and not na(atr_14) and atr_14 > 0
        // Component 1: Direction (-1 or +1)
        float direction = participant == BUYER ? 1.0 : -1.0
        
        // Component 2: Strength (distance from DEFENDED level, not session mid)
        float price_distance = math.abs(price - defended_price)
        float strength = math.min(price_distance / atr_14, 5.0) / 5.0  // Cap at 5 ATR
        
        // Component 3: Persistence (slower decay - intent lingers)
        float persistence = 1.0
        if not na(age_bars) and age_bars > 0
            // Half-life of 50 bars (not 20) - intent persists longer
            persistence := math.exp(-age_bars / 50.0)
        
        // Component 4: Effort (volume influence)
        float effort = 1.0
        if not na(vol_ratio) and vol_ratio > 0
            effort := math.sqrt(math.min(vol_ratio, 3.0) / 3.0)  // Cap at 3x volume
        
        // Composite vector magnitude
        float raw_magnitude = direction * strength * persistence * effort
        
        // Adjust for passive vs aggressor
        if is_passive
            vector := raw_magnitude * 0.75  // Historical pressure
        else
            // Boost aggressor with conviction
            float conviction_mult = conviction ? 1.3 : 1.0
            vector := raw_magnitude * conviction_mult
    
    vector

// Classify absorption (V4.1 - Real-Time Safe, No Future Bias)
f_classify_absorption_type_realtime(price, participant, exhaustion_flag, intent_bal, vec_aggr_mag) =>
    int abs_type = ABS_NONE
    
    if exhaustion_flag and not na(participant)
        // Use INTENT BALANCE instead of future-confirmed swings
        // This is knowable NOW, not after confirmation
        
        float aggr_strength = not na(vec_aggr_mag) ? math.abs(vec_aggr_mag) : 0.0
        float intent_strength = math.abs(intent_bal)
        
        // Classification logic (real-time safe):
        // 1. Strong aggressor + aligned intent = INTERNAL (continuation)
        // 2. Weak aggressor + opposing intent = EXTERNAL (reversal)
        // 3. Ambiguous = EXHAUSTION
        
        bool intent_aligned = (participant == BUYER and intent_bal > 0) or 
                             (participant == SELLER and intent_bal < 0)
        
        if aggr_strength > 0.4 and intent_aligned
            // Strong current push + stored intent = continuation
            abs_type := ABS_INTERNAL
        else if intent_strength > 0.3 and not intent_aligned
            // Intent opposing current participant = reversal likely
            abs_type := ABS_EXTERNAL
        else
            // Weak signals or ambiguous = pure exhaustion
            abs_type := ABS_EXHAUSTION
    
    abs_type

// Calculate vector-based divergence (V4.0 - Energy Differential)
f_calculate_vector_divergence(vec_passive_D, vec_passive_S, vec_aggr_D, vec_aggr_S) =>
    int div_type = DIV_NONE
    float div_strength = 0.0
    int diverged_axes = 0
    
    // Check D-axis (daily) energy imbalance
    if not na(vec_passive_D) and not na(vec_aggr_D)
        // Divergence = opposite signs (opposing forces)
        bool d_diverges = vec_passive_D * vec_aggr_D < 0
        
        // Measure energy imbalance (not just sign disagreement)
        float d_energy_diff = math.abs(vec_passive_D) - math.abs(vec_aggr_D)
        
        // Significant divergence = opposite directions AND meaningful energy gap
        if d_diverges and math.abs(d_energy_diff) > 0.15  // 15% threshold
            diverged_axes += 1
            div_strength += math.abs(d_energy_diff)
    
    // Check S-axis (session) energy imbalance
    if not na(vec_passive_S) and not na(vec_aggr_S)
        bool s_diverges = vec_passive_S * vec_aggr_S < 0
        float s_energy_diff = math.abs(vec_passive_S) - math.abs(vec_aggr_S)
        
        if s_diverges and math.abs(s_energy_diff) > 0.15
            diverged_axes += 1
            div_strength += math.abs(s_energy_diff)
    
    // v4.2.1: Gate divergence by intent conflict (contextual, not mechanical)
    if diverged_axes > 0 and expected_dir != INCONCLUSIVE and enable_intent_memory
        if expected_dir == BUYER and intent_bal < 0
            diverged_axes += 1
            div_strength += math.abs(intent_bal) * 0.5
        if expected_dir == SELLER and intent_bal > 0
            diverged_axes += 1
            div_strength += math.abs(intent_bal) * 0.5
    
    // Classify based on axes count AND strength
    if diverged_axes >= 2 or (diverged_axes == 1 and div_strength > 0.5)
        div_type := DIV_FULL
    else if diverged_axes == 1
        div_type := DIV_PARTIAL
    
    [div_type, diverged_axes, div_strength]

// Calculate intent-aware CPS (V4.1 - Conditional Probability)
f_calculate_conditional_cps(participant_present, wavelength_valid, exhaustion_strength, gap_present, absorption_type, vec_aggr_mag, intent_bal, div_strength, expected_dir) =>
    float cps = 0.0
    
    // Base factors (additive for foundation)
    cps += (participant_present ? 1.0 : 0.0) * participant_weight
    cps += (wavelength_valid ? 1.0 : 0.0) * wavelength_weight
    cps += exhaustion_strength * exhaustion_weight
    cps += (gap_present ? 1.0 : 0.0) * gap_weight
    
    // Intent alignment (CONDITIONAL, not additive)
    bool intent_aligned = (expected_dir == BUYER and intent_bal > intent_flip_threshold) or 
                         (expected_dir == SELLER and intent_bal < -intent_flip_threshold)
    
    float intent_mult = 1.0
    if enable_intent_memory
        if intent_aligned
            // Intent confirms direction - boost probability
            intent_mult := 1.0 + (math.abs(intent_bal) * 0.4)  // Up to 40% boost
        else
            // Intent opposes direction - penalize heavily
            intent_mult := 0.6  // 40% penalty for fighting stored intent
    
    // Absorption type modifier (CONDITIONAL interaction)
    float abs_mult = 1.0
    if absorption_type == ABS_INTERNAL
        // Continuation - penalize if divergence present (contradiction)
        if div_strength > 0.3
            abs_mult := 0.8  // Energy conflict
        else
            abs_mult := 1.1  // Clean continuation
    else if absorption_type == ABS_EXTERNAL
        // Reversal - boost if divergence present (confirmation)
        if div_strength > 0.3
            abs_mult := 1.3  // Energy alignment for reversal
        else
            abs_mult := 0.9  // Reversal without divergence = risky
    else
        // Pure exhaustion - neutral
        abs_mult := 1.0
    
    // Aggressor strength (direct, not compound)
    float aggr_mult = 1.0
    if not na(vec_aggr_mag) and math.abs(vec_aggr_mag) > 0.3
        aggr_mult := 1.0 + (math.abs(vec_aggr_mag) * 0.2)
    
    // Regime adjustment (environmental)
    float regime_adj = regime_confidence_mult
    
    // CONDITIONAL composition (not pure multiplication)
    cps *= intent_mult * abs_mult * regime_adj
    cps *= math.sqrt(aggr_mult)  // Dampened influence
    
    math.min(cps, 1.0)

// =============================================================================
// MAIN LOGIC
// =============================================================================

// =============================================================================
// AXIOM 2: PARTICIPANT IDENTIFICATION (Opening Range + First Move)
// =============================================================================

// Reset on new session
if is_new_session()
    orh := na
    orl := na
    orm := na
    or_formed := false
    or_start_bar := bar_index
    or_end_bar := na
    w_state := STATE_PRE_OR
    current_participant := INCONCLUSIVE
    moves_completed := 0
    flip_point := na
    signal_direction := INCONCLUSIVE
    exhaustion_detected := false
    defended_liquidity := na
    
    // Phase C: Decay wavelength bias on new session
    wavelength_bias *= 0.5  // Partial memory retention
    session_failure_count := 0
    
    // Phase E: No time-based intent reset (structural events only)

// Build Opening Range during OR window
if in_session() and not or_formed
    minutes_elapsed = minutes_since_or()
    
    if minutes_elapsed <= or_window_minutes
        // Accumulate OR high/low
        if na(orh)
            orh := high
            orl := low
        else
            orh := math.max(orh, high)
            orl := math.min(orl, low)
    else
        // OR window closed - calculate midpoint
        if not na(orh) and not or_formed
            orm := (orh + orl) / 2
            or_end_bar := bar_index
            or_formed := true
            w_state := STATE_PART_ID

// Register swing highs and lows for AOI tracking
swing_lookback = 5
detected_swing_high = f_is_swing_high(swing_lookback)
detected_swing_low = f_is_swing_low(swing_lookback)

if not na(detected_swing_high) and or_formed
    swing_vol_at_high = volume[swing_lookback]
    swing_strength = atr_14 > 0 ? math.abs(detected_swing_high - close) / atr_14 : 1.0
    
    array.push(swing_prices, detected_swing_high)
    array.push(swing_owners, BUYER)  // Buyers formed this high
    array.push(swing_bars, bar_index - swing_lookback)
    array.push(swing_types, "HIGH")
    array.push(swing_mitigated, false)
    array.push(swing_volumes, swing_vol_at_high)
    array.push(swing_magnitudes, swing_strength)

if not na(detected_swing_low) and or_formed
    swing_vol_at_low = volume[swing_lookback]
    swing_strength = atr_14 > 0 ? math.abs(close - detected_swing_low) / atr_14 : 1.0
    
    array.push(swing_prices, detected_swing_low)
    array.push(swing_owners, SELLER)  // Sellers formed this low
    array.push(swing_bars, bar_index - swing_lookback)
    array.push(swing_types, "LOW")
    array.push(swing_mitigated, false)
    array.push(swing_volumes, swing_vol_at_low)
    array.push(swing_magnitudes, swing_strength)

// Cleanup old swings (keep last 50)
if array.size(swing_prices) > 50
    array.shift(swing_prices)
    array.shift(swing_owners)
    array.shift(swing_bars)
    array.shift(swing_types)
    array.shift(swing_mitigated)
    array.shift(swing_volumes)
    array.shift(swing_magnitudes)

// Check swing mitigation
if array.size(swing_prices) > 0
    for i = 0 to array.size(swing_prices) - 1
        if not array.get(swing_mitigated, i)
            swing_price = array.get(swing_prices, i)
            swing_type = array.get(swing_types, i)
            
            // Mark as mitigated if price crossed it
            if swing_type == "HIGH" and close > swing_price
                array.set(swing_mitigated, i, true)
            else if swing_type == "LOW" and close < swing_price
                array.set(swing_mitigated, i, true)

// First Move Test - Identify participant by OR sweep
if or_formed and current_participant == INCONCLUSIVE and w_state == STATE_PART_ID
    bars_since_or = bar_index - or_end_bar
    
    // Check first 3 candles after OR closes
    if bars_since_or >= 0 and bars_since_or <= 3
        swept_low = low <= orl
        swept_high = high >= orh
        
        if swept_low and not swept_high
            // SELLERS swept buy-side liquidity
            current_participant := SELLER
            conviction := bars_since_or == 0
            sweep_bar := bar_index
            move_1_extreme := low
            defended_liquidity := orl  // Defended price is OR low (swept level)
            
        else if swept_high and not swept_low
            // BUYERS swept sell-side liquidity
            current_participant := BUYER
            conviction := bars_since_or == 0
            sweep_bar := bar_index
            move_1_extreme := high
            defended_liquidity := orh  // Defended price is OR high (swept level)
            
        else if swept_low and swept_high
            // Both swept - use deeper penetration
            low_pen = orl - low
            high_pen = high - orh
            if low_pen > high_pen
                current_participant := SELLER
                conviction := bars_since_or == 0
                sweep_bar := bar_index
                move_1_extreme := low
                defended_liquidity := orl
            else
                current_participant := BUYER
                conviction := bars_since_or == 0
                sweep_bar := bar_index
                move_1_extreme := high
                defended_liquidity := orh
    
    else if bars_since_or > 3
        // No participant identified - failed
        w_state := STATE_FAILED
        
        // Phase C: Record failure for bias
        if enable_failure_memory
            session_failure_count += 1
            wavelength_bias -= 0.1  // Negative bias accumulation

// =============================================================================
// AXIOM 1: WAVELENGTH STATE MACHINE (3-Move Cycle)
// =============================================================================

// STATE: PART_ID → MOVE_1
if w_state == STATE_PART_ID and current_participant != INCONCLUSIVE
    if current_participant == SELLER
        // Extend Move 1 low
        if low < move_1_extreme
            move_1_extreme := low
        // Check for reversal
        if close > move_1_extreme + (atr_14 * min_move_atr)
            w_state := STATE_MOVE_1
            moves_completed := 1
            move_2_extreme := high
    
    else if current_participant == BUYER
        // Extend Move 1 high
        if high > move_1_extreme
            move_1_extreme := high
        // Check for reversal
        if close < move_1_extreme - (atr_14 * min_move_atr)
            w_state := STATE_MOVE_1
            moves_completed := 1
            move_2_extreme := low

// STATE: MOVE_1 → MOVE_2 (Liquidation Hunt)
if w_state == STATE_MOVE_1
    if current_participant == SELLER
        // Track pullback high
        if high > move_2_extreme
            move_2_extreme := high
        // Check retracement limit
        if not na(orh) and not na(move_1_extreme)
            retrace = (move_2_extreme - move_1_extreme) / (orh - move_1_extreme + 0.01)
            if retrace > max_retracement
                w_state := STATE_FAILED
                
                // Phase C: Record retracement failure
                if enable_failure_memory
                    session_failure_count += 1
                    wavelength_bias -= 0.15
        // Detect reversal back down
        if close < move_2_extreme - (atr_14 * min_move_atr)
            w_state := STATE_MOVE_2
            moves_completed := 2
    
    else if current_participant == BUYER
        // Track pullback low
        if low < move_2_extreme
            move_2_extreme := low
        // Check retracement limit
        if not na(orl) and not na(move_1_extreme)
            retrace = (move_1_extreme - move_2_extreme) / (move_1_extreme - orl + 0.01)
            if retrace > max_retracement
                w_state := STATE_FAILED
                
                // Phase C: Record retracement failure
                if enable_failure_memory
                    session_failure_count += 1
                    wavelength_bias -= 0.15
        // Detect reversal back up
        if close > move_2_extreme + (atr_14 * min_move_atr)
            w_state := STATE_MOVE_2
            moves_completed := 2

// STATE: MOVE_2 → FLIP_CONF (requires exhaustion detection below)

// STATE: FLIP_CONF → MOVE_3 (or failure tracking)
if w_state == STATE_FLIP_CONF
    // Check if flip is stalling (Phase C failure detection)
    bars_in_flip = not na(flip_bar_idx) ? bar_index - flip_bar_idx : 0
    
    if current_participant == SELLER
        // Price should break Move 1 low
        if low < move_1_extreme
            w_state := STATE_MOVE_3
            moves_completed := 3
        else if bars_in_flip > 20  // Flip stalled for 20+ bars
            // Phase C: Register failed flip zone
            if enable_failure_memory and not na(flip_point)
                f_register_failed_flip(flip_point, current_participant)
                w_state := STATE_FAILED
    
    else if current_participant == BUYER
        // Price should break Move 1 high
        if high > move_1_extreme
            w_state := STATE_MOVE_3
            moves_completed := 3
        else if bars_in_flip > 20  // Flip stalled for 20+ bars
            // Phase C: Register failed flip zone
            if enable_failure_memory and not na(flip_point)
                f_register_failed_flip(flip_point, current_participant)
                w_state := STATE_FAILED

// STATE: MOVE_3 → COMPLETE
if w_state == STATE_MOVE_3
    w_state := STATE_COMPLETE

// =============================================================================
// AXIOM 3: EXHAUSTION DETECTION (4-Factor Effort vs Result)
// =============================================================================

// Factor 1: Volume Score (30%)
vol_ratio = volume / avg_volume
vol_score = math.min(vol_ratio, 2.0) / 2.0  // Normalize to [0,1]

// Factor 2: Body Rejection Score (30%)
body_size = math.abs(close - open)
full_range = high - low
body_ratio = full_range > 0 ? body_size / full_range : 0
body_score = 1.0 - body_ratio  // Small body = high score

// Factor 3: Price Stagnation Score (25%)
price_moved = math.abs(close - close[2])
expected_move = atr_14 * (vol_ratio / 2.0)
stag_score = price_moved < expected_move ? 1.0 : 0.0

// Factor 4: Reversal Pattern Score (15%)
rev_score = 0.0
if current_participant == SELLER
    rev_score := close > open ? 1.0 : 0.0  // Bullish reversal
else if current_participant == BUYER
    rev_score := close < open ? 1.0 : 0.0  // Bearish reversal

// Weighted Exhaustion Score
exhaustion_score := (vol_weight * vol_score + 
                     body_weight * body_score + 
                     price_weight * stag_score + 
                     rev_weight * rev_score)

// Apply regime-adjusted threshold (silent adaptation)
float adjusted_threshold = exhaustion_threshold * regime_exhaustion_mult
exhaustion_detected := exhaustion_score >= adjusted_threshold

// Trigger state transition MOVE_2 → FLIP_CONF
if w_state == STATE_MOVE_2 and exhaustion_detected
    w_state := STATE_FLIP_CONF
    flip_point := move_2_extreme
    flip_bar_idx := bar_index

// Classify absorption type (V4.1 - Real-Time Safe)
absorption_type := f_classify_absorption_type_realtime(
    close, current_participant, exhaustion_detected, intent_balance, vec_D_aggressor)

// Calculate absorption strength using vector magnitudes
if absorption_type == ABS_INTERNAL
    // Continuation - blend exhaustion + aggressor vector strength
    float vec_strength = not na(vec_D_aggressor) ? math.abs(vec_D_aggressor) : 0.0
    absorption_strength := (exhaustion_score * 0.6) + (vec_strength * 0.4)
else if absorption_type == ABS_EXTERNAL
    // Reversal - blend exhaustion + passive vector strength (opposing force)
    float passive_strength = not na(vec_D_passive) ? math.abs(vec_D_passive) : 0.0
    absorption_strength := (exhaustion_score * 0.5) + (passive_strength * 0.5)
else if absorption_type == ABS_EXHAUSTION
    absorption_strength := exhaustion_score
else
    absorption_strength := 0.0

// =============================================================================
// AXIOM 4: FUTURES GAP DETECTION & TARGETING
// =============================================================================

// Detect gaps on session opens
if is_new_session() and bar_index > 0
    prev_close = close[1]
    curr_open = open
    gap_size = math.abs(curr_open - prev_close)
    
    if gap_size >= gap_min_points
        gap_mid = (curr_open + prev_close) / 2
        array.push(gap_prices, gap_mid)
        array.push(gap_bars, bar_index)
        array.push(gap_filled, false)

// Check gap fills
if array.size(gap_prices) > 0
    for i = 0 to array.size(gap_prices) - 1
        if not array.get(gap_filled, i)
            gap_price = array.get(gap_prices, i)
            // Consider filled if price touches within tolerance
            if math.abs(close - gap_price) < gap_min_points / 2
                array.set(gap_filled, i, true)
        
        // Remove old gaps
        gap_age = bar_index - array.get(gap_bars, i)
        if gap_age > gap_max_age
            array.set(gap_filled, i, true)

// Find nearest unfilled gap (v4.1 - Intent-Aware)
float nearest_gap = na
if current_participant != INCONCLUSIVE and array.size(gap_prices) > 0
    min_dist = 999999.0
    for i = 0 to array.size(gap_prices) - 1
        if not array.get(gap_filled, i)
            gap_price = array.get(gap_prices, i)
            
            // Check if gap is in participant direction
            valid_dir = (current_participant == BUYER and gap_price > close) or 
                       (current_participant == SELLER and gap_price < close)
            
            // Phase D: Additional check - gap should align with intent
            bool intent_gap_aligned = true
            if enable_intent_memory
                if current_participant == BUYER
                    intent_gap_aligned := intent_balance > -0.2  // Allow if not strongly bearish
                else if current_participant == SELLER
                    intent_gap_aligned := intent_balance < 0.2   // Allow if not strongly bullish
            
            if valid_dir and intent_gap_aligned
                dist = math.abs(gap_price - close)
                if dist < min_dist
                    min_dist := dist
                    nearest_gap := gap_price

// Build PASSIVE vector coordinate (from AOI/swing context)
if array.size(swing_prices) > 0
    // Find most recent unmitigated swing
    for i = array.size(swing_prices) - 1 to 0
        if not array.get(swing_mitigated, i)
            swing_owner = array.get(swing_owners, i)
            swing_price = array.get(swing_prices, i)
            swing_bar = array.get(swing_bars, i)
            swing_vol = array.get(swing_volumes, i)
            
            // Calculate vector with full components
            age = bar_index - swing_bar
            vol_ratio_at_swing = avg_volume > 0 ? swing_vol / avg_volume : 1.0
            
            // Use swing price itself as defended level (not ORM)
            vec_D_passive := f_build_vector_coordinate(
                swing_owner, swing_price, swing_price, age, vol_ratio_at_swing, true)
            vec_D_passive_base := swing_price
            vec_D_passive_age := age
            vec_S_passive := vec_D_passive
            break
else
    vec_D_passive := na
    vec_S_passive := na

// Build AGGRESSOR vector coordinate (from current participant)
vol_ratio_current = avg_volume > 0 ? volume / avg_volume : 1.0
// Use defended_liquidity (swept OR level) as anchor, not ORM
float aggr_baseline = not na(defended_liquidity) ? defended_liquidity : orm
vec_D_aggressor := f_build_vector_coordinate(
    current_participant, close, aggr_baseline, 0, vol_ratio_current, false)
vec_D_aggressor_base := aggr_baseline
vec_D_aggressor_age := 0
vec_S_aggressor := vec_D_aggressor

// Legacy coordinate (derived from vector sign)
coord_D := not na(vec_D_aggressor) ? (vec_D_aggressor > 0 ? 1 : (vec_D_aggressor < 0 ? -1 : 0)) : na

// Detect Multi-Axis Divergence (V4.0 Vector Energy)
if not na(vec_D_passive) and not na(vec_D_aggressor)
    [div_t, div_axes, div_str] = f_calculate_vector_divergence(
        vec_D_passive, vec_S_passive,
        vec_D_aggressor, vec_S_aggressor)
    divergence_type := div_t
    divergence_axes := div_axes
    divergence_score := div_str  // Now represents energy imbalance magnitude
else
    divergence_type := DIV_NONE
    divergence_axes := 0
    divergence_score := 0.0

// Register Liquidity Zones on flip (v4.1 - Defended Liquidity)
if w_state == STATE_FLIP_CONF and bar_index == flip_bar_idx and not na(current_participant)
    // Use flip point as zone, but annotate with defended liquidity context
    zone_price = flip_point
    f_register_zone(zone_price, current_participant)
    
    // Phase D: Record intent state at zone creation
    if enable_intent_memory
        // This helps later analysis of why zones succeed/fail
        intent_magnitude := math.abs(intent_balance)

// Update Zone Mitigation Status
if array.size(zone_prices) > 0
    for i = 0 to array.size(zone_prices) - 1
        if array.get(zone_status, i) == ZONE_ACTIVE
            zone_price = array.get(zone_prices, i)
            if f_check_mitigation(zone_price, close, 0.001)
                array.set(zone_status, i, ZONE_MITIGATED)

// =============================================================================
// CPS CALCULATION & SIGNAL GENERATION
// =============================================================================

// PROBABILISTIC CPS (resolution likelihood, not direction)
participant_present = current_participant != INCONCLUSIVE
wavelength_valid = (w_state == STATE_FLIP_CONF or w_state == STATE_MOVE_3 or w_state == STATE_COMPLETE)
absorption_clear = (absorption_type == ABS_INTERNAL or absorption_type == ABS_EXTERNAL)
gap_present = not na(nearest_gap)

// Calculate intent-aware conditional CPS (V4.1)
signal_confidence := f_calculate_conditional_cps(
    participant_present,
    wavelength_valid,
    exhaustion_score,
    gap_present,
    absorption_type,
    vec_D_aggressor,
    intent_balance,
    divergence_score,
    expected_direction)

// Phase C: Apply failure memory penalty
if enable_failure_memory and not na(flip_point)
    [near_fail, fail_bias, repeat_count] = f_near_failed_zone(flip_point, 2.0)
    if near_fail
        signal_confidence *= failure_penalty  // Penalize CPS
        
        // Extra penalty for repeat failures
        if repeat_count > 2
            signal_confidence *= 0.85

// v4.2.2: Apply wavelength bias with floor (feedback loop)
signal_confidence *= math.max(0.7, 1.0 + wavelength_bias)

// Phase C: Apply wavelength bias (accumulated session failures)
if enable_failure_memory
    bias_mult = 1.0 + math.max(wavelength_bias, -0.4)  // Cap at 40% penalty
    signal_confidence *= bias_mult

// DIRECTION determined by absorption type, divergence, AND intent (v4.1)
int expected_direction = INCONCLUSIVE

// Phase D: Check intent state first
float intent_strength = enable_intent_memory ? math.abs(intent_balance) : 0.0
bool intent_is_strong = intent_strength > 0.4

if absorption_type == ABS_INTERNAL
    // Internal = continuation in current participant direction
    expected_direction := current_participant
    
    // Phase D: Validate with intent
    if intent_is_strong and enable_intent_memory
        bool intent_agrees = (current_participant == BUYER and intent_balance > 0) or 
                            (current_participant == SELLER and intent_balance < 0)
        if not intent_agrees
            // Intent opposes continuation - downgrade to ambiguous
            expected_direction := INCONCLUSIVE
            
else if absorption_type == ABS_EXTERNAL
    // External = reversal (opposite of current participant)
    expected_direction := current_participant == BUYER ? SELLER : (current_participant == SELLER ? BUYER : INCONCLUSIVE)
    
    // Phase D: Validate with intent flip
    if intent_is_strong and enable_intent_memory
        bool intent_flipped = (expected_direction == BUYER and intent_balance > 0.2) or 
                             (expected_direction == SELLER and intent_balance < -0.2)
        if not intent_flipped
            // Intent hasn't flipped yet - reversal premature
            expected_direction := INCONCLUSIVE
            
else if absorption_type == ABS_EXHAUSTION
    // Exhaustion without clear context - use divergence AND intent as tiebreaker
    if divergence_type == DIV_FULL
        expected_direction := current_participant == BUYER ? SELLER : (current_participant == SELLER ? BUYER : INCONCLUSIVE)
        
        // Phase D: Require intent confirmation for exhaustion-based reversal
        if enable_intent_memory and intent_strength > 0.3
            bool intent_supports_reversal = (expected_direction == BUYER and intent_balance > 0.2) or 
                                           (expected_direction == SELLER and intent_balance < -0.2)
            if not intent_supports_reversal
                expected_direction := INCONCLUSIVE
    else
        // No divergence - default to continuation if intent supports
        if enable_intent_memory and intent_strength > 0.3
            if intent_balance > 0.2
                expected_direction := BUYER
            else if intent_balance < -0.2
                expected_direction := SELLER
        else
            expected_direction := current_participant

// Generate signals (persist for 5 bars after flip)
bars_since_flip = not na(flip_bar_idx) ? bar_index - flip_bar_idx : 999

// Signal requirements:
// 1. Valid wavelength state
// 2. High confidence (probabilistic CPS)
// 3. Clear absorption type (not exhaustion-only unless divergence present)
// 4. Direction matches expected outcome
// 5. Phase B: Regime tradeable (not compressed or time-filtered)
// 6. Phase C: Not near repeated failure zone

valid_state = (w_state == STATE_FLIP_CONF or w_state == STATE_MOVE_3)
high_confidence = signal_confidence >= confluence_threshold
absorption_tradeable = (absorption_type == ABS_INTERNAL or absorption_type == ABS_EXTERNAL or 
                       (absorption_type == ABS_EXHAUSTION and divergence_type != DIV_NONE))
within_window = not na(flip_bar_index) and bars_since_flip >= 0 and bars_since_flip <= 5

// Phase B: Regime and time filters
regime_allows = regime_tradeable and time_tradeable

// Phase C: Check for high-risk repeat failure zones
bool not_repeat_failure = true
if enable_failure_memory and not na(flip_point)
    [near_fail, fail_bias, repeat_count] = f_near_failed_zone(flip_point, 2.0)
    if near_fail and repeat_count >= 3  // Block if 3+ failures at this zone
        not_repeat_failure := false

// Phase D: Intent alignment gate (v4.1)
bool intent_allows = true
if enable_intent_memory
    // v4.2.1: Regime-adaptive threshold
    float intent_thresh = regime_state == "COMPRESSED" ? 0.35 : regime_state == "EXPANSION" ? 0.15 : intent_flip_threshold
    if expected_direction == BUYER
        intent_allows := intent_balance > intent_thresh
    else if expected_direction == SELLER
        intent_allows := intent_balance < -intent_thresh

// Phase E: HTF permission gate (v4.2 - Authority Hierarchy)
// HTFs GATE signals, they don't boost CPS
bool htf_allows = htf_permission

buy_signal = valid_state and high_confidence and absorption_tradeable and within_window and 
             expected_direction == BUYER and regime_allows and not_repeat_failure and intent_allows and htf_allows

sell_signal = valid_state and high_confidence and absorption_tradeable and within_window and 
              expected_direction == SELLER and regime_allows and not_repeat_failure and intent_allows and htf_allows

// Set signal parameters (only on flip bar)
if (buy_signal or sell_signal) and bar_index == flip_bar_idx
    signal_direction := expected_direction  // Use expected_direction (intent-validated)
    entry_price := flip_point
    stop_price := move_1_extreme
    
    // Target: Use intent-aligned gap if available, otherwise 1:2 R:R
    risk = math.abs(entry_price - stop_price)
    if not na(nearest_gap)
        // Gap is already intent-aligned from gap selection logic
        target_price := nearest_gap
    else
        // Default R:R target, adjusted by intent strength
        float rr_mult = 2.0
        if enable_intent_memory and intent_magnitude > 0.5
            rr_mult := 2.5  // Stronger intent = larger target
        
        target_price := expected_direction == BUYER ? (entry_price + rr_mult * risk) : (entry_price - rr_mult * risk)
    
    // Record signal in history (v4.1 - with intent metadata)
    array.push(hist_signal_bars, bar_index)
    array.push(hist_signal_dirs, expected_direction)  // Use expected_direction
    array.push(hist_entry_prices, entry_price)
    array.push(hist_stop_prices, stop_price)
    array.push(hist_target_prices, target_price)
    array.push(hist_outcomes, 0)  // Pending
    array.push(hist_cps_scores, signal_confidence)
    array.push(hist_rr_ratios, 0.0)  // Unknown yet
    
    total_signals += 1

// =============================================================================
// SIGNAL OUTCOME TRACKING
// =============================================================================

// Update outcomes for pending signals
if array.size(hist_signal_bars) > 0
    for i = 0 to array.size(hist_signal_bars) - 1
        current_outcome = array.get(hist_outcomes, i)
        
        // Only process pending signals
        if current_outcome == 0
            signal_bar = array.get(hist_signal_bars, i)
            signal_dir = array.get(hist_signal_dirs, i)
            signal_entry = array.get(hist_entry_prices, i)
            signal_stop = array.get(hist_stop_prices, i)
            signal_target = array.get(hist_target_prices, i)
            
            bars_since_signal = bar_index - signal_bar
            
            // Check if enough bars have passed
            if bars_since_signal >= outcome_bars
                // Determine outcome based on what happened
                hit_target = false
                hit_stop = false
                final_rr = 0.0
                
                // Check if target or stop was hit within outcome_bars window
                for j = 1 to outcome_bars
                    if signal_bar + j <= bar_index
                        bars_ago = bar_index - (signal_bar + j)
                        check_high = high[bars_ago]
                        check_low = low[bars_ago]
                        
                        if signal_dir == BUYER
                            if check_high >= signal_target
                                hit_target := true
                            if check_low <= signal_stop
                                hit_stop := true
                        else if signal_dir == SELLER
                            if check_low <= signal_target
                                hit_target := true
                            if check_high >= signal_stop
                                hit_stop := true
                
                // Calculate outcome
                risk = math.abs(signal_entry - signal_stop)
                
                if hit_target and not hit_stop
                    // Win
                    reward = math.abs(signal_target - signal_entry)
                    final_rr := reward / risk
                    array.set(hist_outcomes, i, 1)
                    array.set(hist_rr_ratios, i, final_rr)
                    total_wins += 1
                    total_rr += final_rr
                else if hit_stop
                    // Loss
                    final_rr := -1.0
                    array.set(hist_outcomes, i, -1)
                    array.set(hist_rr_ratios, i, final_rr)
                    total_losses += 1
                    total_rr += final_rr
                else
                    // Neither hit - check current position
                    float current_pnl = signal_dir == BUYER ? (close - signal_entry) : (signal_entry - close)
                    
                    if current_pnl > 0
                        // Winning
                        final_rr := math.abs(current_pnl) / risk
                        array.set(hist_outcomes, i, 1)
                        array.set(hist_rr_ratios, i, final_rr)
                        total_wins += 1
                        total_rr += final_rr
                    else if current_pnl < -risk * 0.9
                        // Losing
                        final_rr := current_pnl / risk
                        array.set(hist_outcomes, i, -1)
                        array.set(hist_rr_ratios, i, final_rr)
                        total_losses += 1
                        total_rr += final_rr
                    else
                        // Breakeven
                        array.set(hist_outcomes, i, 2)
                        array.set(hist_rr_ratios, i, 0.0)
                        total_breakeven += 1

// =============================================================================
// VISUAL OUTPUT
// =============================================================================

// Opening Range Box
if show_or_box and or_formed and not na(orh)
    color box_color = current_participant == BUYER ? color.new(color.green, 85) : 
                      current_participant == SELLER ? color.new(color.red, 85) : 
                      color.new(color.gray, 90)
    var box or_box = na
    or_box := box.new(or_start_bar, orh, or_end_bar + 50, orl, 
                     border_color=box_color, bgcolor=box_color)

// Defended Liquidity Line (v4.1)
if show_wavelength and not na(defended_liquidity) and or_formed
    line.new(or_end_bar, defended_liquidity, bar_index, defended_liquidity,
            color=color.new(color.blue, 60), width=2, style=line.style_solid,
            extend=extend.none)

// Flip Point Markers
if show_wavelength and not na(flip_point) and bar_index == flip_bar_idx
    label.new(flip_bar_idx, flip_point, "FLIP", 
             style=label.style_circle, size=size.small,
             color=current_participant == BUYER ? color.green : color.red,
             textcolor=color.white)

// Plot signals
plotshape(show_signals and buy_signal, "Buy Signal", shape.triangleup, location.belowbar, 
         color.new(color.lime, 0), size=size.normal)
plotshape(show_signals and sell_signal, "Sell Signal", shape.triangledown, location.abovebar, 
         color.new(color.red, 0), size=size.normal)

// =============================================================================
// SIGNAL HISTORY VISUALIZATION
// =============================================================================

// Display historical signals with outcome indicators
if show_signal_history and array.size(hist_signal_bars) > 0
    start_idx = show_all_history ? 0 : math.max(0, array.size(hist_signal_bars) - lookback_period)
    
    // Limit rendering based on visible bars to maintain performance
    visible_bar_threshold = bar_index - history_bars_visible
    
    for i = start_idx to array.size(hist_signal_bars) - 1
        sig_bar = array.get(hist_signal_bars, i)
        sig_dir = array.get(hist_signal_dirs, i)
        sig_entry = array.get(hist_entry_prices, i)
        sig_outcome = array.get(hist_outcomes, i)
        sig_rr = array.get(hist_rr_ratios, i)
        sig_cps = array.get(hist_cps_scores, i)
        
        // Only show if within visible range (performance optimization)
        if sig_bar >= visible_bar_threshold
            // Determine color based on outcome
            label_color = color.gray
            outcome_text = ""
            
            if sig_outcome == 1  // Win
                label_color := sig_dir == BUYER ? color.new(color.lime, 20) : color.new(color.lime, 20)
                outcome_text := "✓ " + str.tostring(math.round(sig_rr, 2)) + "R"
            else if sig_outcome == -1  // Loss
                label_color := color.new(color.red, 20)
                outcome_text := "✗ " + str.tostring(math.round(sig_rr, 2)) + "R"
            else if sig_outcome == 2  // Breakeven
                label_color := color.new(color.orange, 20)
                outcome_text := "BE"
            else  // Pending
                label_color := sig_dir == BUYER ? color.new(color.blue, 20) : color.new(color.blue, 20)
                outcome_text := "..."
            
            // Create label with signal info
            signal_label_text = outcome_text + "\nCPS:" + str.tostring(math.round(sig_cps * 100)) + "%"
            
            if sig_dir == BUYER
                label.new(sig_bar, sig_entry, signal_label_text, 
                         style=label.style_label_up, size=size.small,
                         color=label_color, textcolor=color.white,
                         tooltip="Entry: " + str.tostring(sig_entry) + "\nOutcome: " + outcome_text)
            else
                label.new(sig_bar, sig_entry, signal_label_text, 
                         style=label.style_label_down, size=size.small,
                         color=label_color, textcolor=color.white,
                         tooltip="Entry: " + str.tostring(sig_entry) + "\nOutcome: " + outcome_text)
            
            // Draw reference lines for completed signals (only recent ones for performance)
            if sig_outcome != 0 and sig_outcome != 2 and sig_bar >= bar_index - 100  // Win or Loss, last 100 bars
                sig_stop = array.get(hist_stop_prices, i)
                sig_target = array.get(hist_target_prices, i)
                
                // Entry line
                line.new(sig_bar, sig_entry, sig_bar + outcome_bars, sig_entry,
                        color=color.new(color.blue, 70), width=1, style=line.style_solid)
                
                // Stop line
                line.new(sig_bar, sig_stop, sig_bar + outcome_bars, sig_stop,
                        color=color.new(color.red, 70), width=1, style=line.style_dotted)
                
                // Target line
                line.new(sig_bar, sig_target, sig_bar + outcome_bars, sig_target,
                        color=color.new(color.green, 70), width=1, style=line.style_dotted)

// Plot exhaustion markers
plotshape(show_wavelength and exhaustion_detected, "Exhaustion", shape.diamond, location.abovebar,
         color.new(color.yellow, 0), size=size.tiny)

// Plot intent balance as background (v4.1)
if enable_intent_memory
    intent_color = intent_balance > 0.3 ? color.new(color.green, 95) : 
                  intent_balance < -0.3 ? color.new(color.red, 95) : na
    bgcolor(intent_color, title="Intent Balance")

// Plot coordinates as labels
if show_coordinates and bar_index % 10 == 0 and not na(coord_D)
    coord_text = coord_D == 1 ? "D+" : coord_D == -1 ? "D-" : "D?"
    label.new(bar_index, high, coord_text, style=label.style_label_down, size=size.tiny, 
              color=coord_D == 1 ? color.new(color.green, 70) : color.new(color.red, 70),
              textcolor=color.white)

// Plot divergence indicator
color div_color = divergence_type == DIV_FULL ? color.new(color.purple, 90) : 
                  divergence_type == DIV_PARTIAL ? color.new(color.orange, 90) : na
bgcolor(show_divergence ? div_color : na, title="Divergence")

// Draw failed flip zones (Phase C visualization)
if show_wavelength and array.size(failed_flip_prices) > 0 and barstate.islast
    for i = 0 to math.min(array.size(failed_flip_prices) - 1, 9)  // Show last 10
        fail_price = array.get(failed_flip_prices, i)
        fail_count = array.get(failed_flip_count, i)
        fail_bar = array.get(failed_flip_bars, i)
        
        // Color intensity based on failure count
        fail_alpha = fail_count == 1 ? 95 : fail_count == 2 ? 90 : 85
        
        // Draw dashed red line
        line.new(x1=bar_index - 100, y1=fail_price, x2=bar_index, y2=fail_price,
                color=color.new(color.red, fail_alpha), width=2, style=line.style_dotted)
        
        // Label with failure count
        if fail_count > 1
            label.new(bar_index - 50, fail_price, "⚠ " + str.tostring(fail_count) + "x",
                     style=label.style_label_left, size=size.tiny,
                     color=color.new(color.red, 80), textcolor=color.white)

// Draw liquidity zones (limited to last 20 for performance)
if show_wavelength and array.size(zone_prices) > 0 and barstate.islast
    zones_to_show = math.min(array.size(zone_prices), 20)
    start_zone = math.max(0, array.size(zone_prices) - zones_to_show)
    
    for i = start_zone to array.size(zone_prices) - 1
        if array.get(zone_status, i) == ZONE_ACTIVE
            zone_price = array.get(zone_prices, i)
            zone_type = array.get(zone_types, i)
            color zone_color = zone_type == BUYER ? color.new(color.green, 90) : color.new(color.red, 90)
            line.new(x1=bar_index - 50, y1=zone_price, x2=bar_index, y2=zone_price, 
                     color=zone_color, width=1, style=line.style_dashed)

// Entry/Stop/Target Lines (when signal active)
if not na(entry_price) and bar_index >= flip_bar_idx and bar_index <= flip_bar_idx + 50
    line.new(flip_bar_idx, entry_price, bar_index, entry_price, 
            color=color.blue, width=2, style=line.style_solid, extend=extend.none)
    line.new(flip_bar_idx, stop_price, bar_index, stop_price, 
            color=color.red, width=1, style=line.style_dashed, extend=extend.none)
    if not na(target_price)
        line.new(flip_bar_idx, target_price, bar_index, target_price, 
                color=color.green, width=1, style=line.style_dashed, extend=extend.none)

// =============================================================================
// ALERTS (v4.1 - Intent-Aware)
// =============================================================================

string alert_intent = enable_intent_memory ? " | Intent: " + str.tostring(math.round(intent_balance, 2)) : ""

alertcondition(buy_signal and enable_alerts, "HORC Long", 
              "LONG @ {{close}} | CPS: {{plot_0}}" + alert_intent)
alertcondition(sell_signal and enable_alerts, "HORC Short", 
              "SHORT @ {{close}} | CPS: {{plot_0}}" + alert_intent)
alertcondition(exhaustion_detected and enable_alerts, "Exhaustion", 
              "Exhaustion detected: {{plot_1}}" + alert_intent)
alertcondition(divergence_type == DIV_FULL and enable_alerts, "Divergence", 
              "Full divergence detected" + alert_intent)

// =============================================================================
// INFORMATION TABLE
// =============================================================================

if show_table
    var table info_table = table.new(position.top_right, 2, 12, bgcolor=color.new(color.black, 85), border_width=1)
    
    if barstate.islast
        table.cell(info_table, 0, 0, "HORC v4.2.2", text_color=color.white, text_size=size.normal)
        // Phase B: Enhanced regime display with tradeable status
        regime_display = regime_state + (regime_tradeable ? "" : "🚫")
        regime_color = regime_state == "COMPRESSED" ? color.blue : 
                      regime_state == "EXPANSION" ? color.orange : color.gray
        regime_color := regime_tradeable ? regime_color : color.red
        table.cell(info_table, 1, 0, regime_display, text_color=regime_color, text_size=size.small)
        
        table.cell(info_table, 0, 1, "State", text_color=color.gray, text_size=size.small)
        table.cell(info_table, 1, 1, w_state, text_color=color.white, text_size=size.small)
        
        table.cell(info_table, 0, 2, "Participant", text_color=color.gray, text_size=size.small)
        participant_text = current_participant == BUYER ? "BUYER" : current_participant == SELLER ? "SELLER" : "NONE"
        table.cell(info_table, 1, 2, participant_text, 
                   text_color=current_participant == BUYER ? color.green : current_participant == SELLER ? color.red : color.gray, 
                   text_size=size.small)
        
        table.cell(info_table, 0, 3, "Moves", text_color=color.gray, text_size=size.small)
        table.cell(info_table, 1, 3, str.tostring(moves_completed) + "/3", text_color=color.white, text_size=size.small)
        
        table.cell(info_table, 0, 4, "OR", text_color=color.gray, text_size=size.small)
        or_text = or_formed ? "FORMED" : "FORMING"
        table.cell(info_table, 1, 4, or_text, text_color=or_formed ? color.green : color.orange, text_size=size.small)
        
        table.cell(info_table, 0, 5, "Vectors", text_color=color.gray, text_size=size.small)
        // Display vector magnitudes with sign
        vec_passive_display = not na(vec_D_passive) ? 
            (vec_D_passive > 0 ? "P+" : "P-") + str.tostring(math.round(math.abs(vec_D_passive) * 100)) : "--"
        vec_aggr_display = not na(vec_D_aggressor) ? 
            (vec_D_aggressor > 0 ? "A+" : "A-") + str.tostring(math.round(math.abs(vec_D_aggressor) * 100)) : "--"
        coord_text = vec_passive_display + "/" + vec_aggr_display
        table.cell(info_table, 1, 5, coord_text, text_color=color.white, text_size=size.small)
        
        table.cell(info_table, 0, 6, "HTF Align", text_color=color.gray, text_size=size.small)
        // Phase E: Show timeframe alignment (v4.2)
        htf_text = str.tostring(coord_alignment) + "/4"
        htf_color = coord_alignment >= 3 ? color.lime : coord_alignment >= 2 ? color.yellow : color.red
        htf_text += htf_permission ? " ✓" : " ✘"
        table.cell(info_table, 1, 6, htf_text, text_color=htf_color, text_size=size.small)
        
        table.cell(info_table, 0, 7, "Divergence", text_color=color.gray, text_size=size.small)
        div_text = divergence_type == DIV_FULL ? "FULL(" + str.tostring(divergence_axes) + ")" : 
                   divergence_type == DIV_PARTIAL ? "PART(" + str.tostring(divergence_axes) + ")" : "NONE"
        table.cell(info_table, 1, 7, div_text, text_color=color.purple, text_size=size.small)
        
        table.cell(info_table, 0, 8, "Absorption", text_color=color.gray, text_size=size.small)
        abs_text = absorption_type == ABS_INTERNAL ? "INTERNAL" : 
                   absorption_type == ABS_EXTERNAL ? "EXTERNAL" : 
                   absorption_type == ABS_EXHAUSTION ? "EXHAUST" : "NONE"
        abs_color = absorption_type == ABS_INTERNAL ? color.green : 
                    absorption_type == ABS_EXTERNAL ? color.orange : 
                    absorption_type == ABS_EXHAUSTION ? color.yellow : color.gray
        table.cell(info_table, 1, 8, abs_text, text_color=abs_color, text_size=size.small)
        
        table.cell(info_table, 0, 9, "CPS", text_color=color.gray, text_size=size.small)
        cps_text = str.tostring(math.round(math.abs(signal_confidence) * 100)) + "%"
        cps_color = math.abs(signal_confidence) >= confluence_threshold ? color.lime : color.gray
        table.cell(info_table, 1, 9, cps_text, text_color=cps_color, text_size=size.small)
        
        table.cell(info_table, 0, 10, "Status", text_color=color.gray, text_size=size.small)
        // Phase D: Show intent alignment in status
        status_text = "SCANNING"
        status_color = color.gray
        
        if signal_direction == BUYER or signal_direction == SELLER
            status_text := signal_direction == BUYER ? "LONG" : "SHORT"
            status_color := signal_direction == BUYER ? color.green : color.red
            
            // Add intent indicator
            if enable_intent_memory
                bool aligned = (signal_direction == BUYER and intent_balance > 0.2) or 
                              (signal_direction == SELLER and intent_balance < -0.2)
                if aligned
                    status_text += " ✓"  // Checkmark for alignment
                else
                    status_text += " ?"
        
        table.cell(info_table, 1, 10, status_text, text_color=status_color, text_size=size.small)

// =============================================================================
// PHASE B/C MONITORING TABLE (Optional)
// =============================================================================

if show_table and barstate.islast
    var table phase_table = table.new(position.top_left, 2, 9, bgcolor=color.new(color.black, 85), border_width=1)
    
    // Header
    table.cell(phase_table, 0, 0, "ENGINE SYNC", text_color=color.white, text_size=size.normal)
    sync_status = "v4.2.2"
    table.cell(phase_table, 1, 0, sync_status, text_color=color.lime, text_size=size.small)
    
    // Phase E: HTF Breakdown
    table.cell(phase_table, 0, 1, "HTF M/W/D/S", text_color=color.gray, text_size=size.small)
    htf_breakdown = ""
    htf_breakdown += htf_M_direction == BUYER ? "B" : htf_M_direction == SELLER ? "S" : "-"
    htf_breakdown += "/"
    htf_breakdown += htf_W_direction == BUYER ? "B" : htf_W_direction == SELLER ? "S" : "-"
    htf_breakdown += "/"
    htf_breakdown += coord_D == 1 ? "B" : coord_D == -1 ? "S" : "-"
    htf_breakdown += "/"
    htf_breakdown += current_participant == BUYER ? "B" : current_participant == SELLER ? "S" : "-"
    table.cell(phase_table, 1, 1, htf_breakdown, text_color=color.white, text_size=size.small)
    
    // Phase B: Regime Status
    table.cell(phase_table, 0, 2, "Regime", text_color=color.gray, text_size=size.small)
    table.cell(phase_table, 1, 2, regime_state, text_color=regime_color, text_size=size.small)
    
    table.cell(phase_table, 0, 3, "Vol Ratio", text_color=color.gray, text_size=size.small)
    table.cell(phase_table, 1, 3, str.tostring(math.round(regime_volatility, 2)), 
               text_color=color.white, text_size=size.small)
    
    table.cell(phase_table, 0, 4, "Trade OK", text_color=color.gray, text_size=size.small)
    trade_ok_text = regime_tradeable and time_tradeable and htf_permission ? "YES" : "NO"
    trade_ok_color = regime_tradeable and time_tradeable and htf_permission ? color.green : color.red
    table.cell(phase_table, 1, 4, trade_ok_text, text_color=trade_ok_color, text_size=size.small)
    
    // Phase C: Memory Status
    table.cell(phase_table, 0, 5, "Failed Zones", text_color=color.gray, text_size=size.small)
    table.cell(phase_table, 1, 5, str.tostring(array.size(failed_flip_prices)), 
               text_color=color.orange, text_size=size.small)
    
    table.cell(phase_table, 0, 6, "Sess Fails", text_color=color.gray, text_size=size.small)
    table.cell(phase_table, 1, 6, str.tostring(session_failure_count), 
               text_color=session_failure_count > 2 ? color.red : color.yellow, text_size=size.small)
    
    table.cell(phase_table, 0, 7, "Wave Bias", text_color=color.gray, text_size=size.small)
    bias_pct = math.round(wavelength_bias * 100)
    bias_color = bias_pct >= 0 ? color.green : bias_pct > -20 ? color.yellow : color.red
    table.cell(phase_table, 1, 7, str.tostring(bias_pct) + "%", text_color=bias_color, text_size=size.small)
    
    table.cell(phase_table, 0, 8, "Alignment", text_color=color.gray, text_size=size.small)
    align_text = str.tostring(coord_alignment) + "/4"
    align_color = coord_alignment >= 3 ? color.lime : coord_alignment >= 2 ? color.yellow : color.red
    table.cell(phase_table, 1, 8, align_text, text_color=align_color, text_size=size.small)

// Phase D: Intent Memory Table (v4.1)
if show_table and barstate.islast and enable_intent_memory
    var table intent_table = table.new(position.bottom_left, 2, 4, bgcolor=color.new(color.black, 85), border_width=1)
    
    table.cell(intent_table, 0, 0, "INTENT", text_color=color.white, text_size=size.normal)
    intent_dir = intent_balance > 0 ? "BULL" : intent_balance < 0 ? "BEAR" : "FLAT"
    intent_color = intent_balance > 0 ? color.green : intent_balance < 0 ? color.red : color.gray
    table.cell(intent_table, 1, 0, intent_dir, text_color=intent_color, text_size=size.small)
    
    table.cell(intent_table, 0, 1, "Balance", text_color=color.gray, text_size=size.small)
    table.cell(intent_table, 1, 1, str.tostring(math.round(intent_balance, 2)), 
               text_color=color.white, text_size=size.small)
    
    table.cell(intent_table, 0, 2, "Magnitude", text_color=color.gray, text_size=size.small)
    table.cell(intent_table, 1, 2, str.tostring(math.round(intent_magnitude * 100)) + "%", 
               text_color=color.yellow, text_size=size.small)
    
    table.cell(intent_table, 0, 3, "Bars Held", text_color=color.gray, text_size=size.small)
    bars_color = intent_bars_held > 20 ? color.lime : intent_bars_held > 10 ? color.yellow : color.gray
    table.cell(intent_table, 1, 3, str.tostring(intent_bars_held), 
               text_color=bars_color, text_size=size.small)

// =============================================================================
// ACCURACY PERFORMANCE TABLE
// =============================================================================

if show_accuracy_table
    var table acc_table = table.new(position.bottom_right, 2, 8, bgcolor=color.new(color.black, 85), border_width=1)
    
    if barstate.islast
        // Calculate performance metrics
        completed_signals = total_wins + total_losses + total_breakeven
        win_rate = completed_signals > 0 ? (total_wins / completed_signals) * 100 : 0.0
        avg_rr = completed_signals > 0 ? total_rr / completed_signals : 0.0
        expectancy = completed_signals > 0 ? (win_rate / 100) * avg_rr : 0.0
        
        // Calculate lookback window stats
        lookback_wins = 0
        lookback_losses = 0
        lookback_breakeven = 0
        lookback_total_rr = 0.0
        
        if array.size(hist_signal_bars) > 0
            start_idx = math.max(0, array.size(hist_signal_bars) - lookback_period)
            for i = start_idx to array.size(hist_signal_bars) - 1
                outcome = array.get(hist_outcomes, i)
                if outcome == 1
                    lookback_wins += 1
                    lookback_total_rr += array.get(hist_rr_ratios, i)
                else if outcome == -1
                    lookback_losses += 1
                    lookback_total_rr += array.get(hist_rr_ratios, i)
                else if outcome == 2
                    lookback_breakeven += 1
        
        lookback_completed = lookback_wins + lookback_losses + lookback_breakeven
        lookback_win_rate = lookback_completed > 0 ? (lookback_wins / lookback_completed) * 100 : 0.0
        lookback_avg_rr = lookback_completed > 0 ? lookback_total_rr / lookback_completed : 0.0
        
        // Header
        display_mode = show_all_history ? "ALL" : str.tostring(lookback_period)
        table.cell(acc_table, 0, 0, "📊 PERFORMANCE", text_color=color.white, text_size=size.normal)
        table.cell(acc_table, 1, 0, display_mode + " Signals", text_color=color.gray, text_size=size.small)
        
        // Total Signals
        table.cell(acc_table, 0, 1, "Total", text_color=color.gray, text_size=size.small)
        table.cell(acc_table, 1, 1, str.tostring(total_signals), text_color=color.white, text_size=size.small)
        
        // Completed
        table.cell(acc_table, 0, 2, "Completed", text_color=color.gray, text_size=size.small)
        table.cell(acc_table, 1, 2, str.tostring(lookback_completed), text_color=color.white, text_size=size.small)
        
        // Wins
        table.cell(acc_table, 0, 3, "Wins", text_color=color.gray, text_size=size.small)
        table.cell(acc_table, 1, 3, str.tostring(lookback_wins), text_color=color.green, text_size=size.small)
        
        // Losses
        table.cell(acc_table, 0, 4, "Losses", text_color=color.gray, text_size=size.small)
        table.cell(acc_table, 1, 4, str.tostring(lookback_losses), text_color=color.red, text_size=size.small)
        
        // Win Rate
        table.cell(acc_table, 0, 5, "Win Rate", text_color=color.gray, text_size=size.small)
        wr_color = lookback_win_rate >= 60 ? color.green : lookback_win_rate >= 50 ? color.orange : color.red
        table.cell(acc_table, 1, 5, str.tostring(math.round(lookback_win_rate, 1)) + "%", 
                   text_color=wr_color, text_size=size.small)
        
        // Average R:R
        table.cell(acc_table, 0, 6, "Avg R:R", text_color=color.gray, text_size=size.small)
        rr_color = lookback_avg_rr >= 0 ? color.green : color.red
        table.cell(acc_table, 1, 6, str.tostring(math.round(lookback_avg_rr, 2)) + "R", 
                   text_color=rr_color, text_size=size.small)
        
        // Expectancy
        table.cell(acc_table, 0, 7, "Expectancy", text_color=color.gray, text_size=size.small)
        exp_color = expectancy >= 0.5 ? color.lime : expectancy >= 0 ? color.orange : color.red
        table.cell(acc_table, 1, 7, str.tostring(math.round(expectancy, 2)), 
                   text_color=exp_color, text_size=size.small)

// Plots for data window
plot(signal_confidence, "CPS", color.new(color.purple, 0), linewidth=2, display=display.data_window)
plot(exhaustion_score, "Exhaustion", color.new(color.yellow, 0), linewidth=1, display=display.data_window)
plot(moves_completed, "Moves", color.new(color.blue, 0), linewidth=1, display=display.data_window)
plot(intent_balance, "Intent Balance", color.new(color.cyan, 0), linewidth=2, display=display.data_window)
plot(regime_volatility, "Regime Vol", color.new(color.orange, 0), linewidth=1, display=display.data_window)

// =============================================================================
// ENGINE SYNCHRONIZATION VALIDATION (v4.2.1)
// =============================================================================
// CRITICAL FIXES:
// - Intent saturation: tanh soft clamp (prevents runaway bias)
// - Divergence gating: intent conflict detection (contextual classification)
// - Multiplicative CPS: conditional probability (not additive)
// - Active failure memory: CPS penalty in repeat zones
//
// AUTHORITY HIERARCHY:
// - Monthly/Weekly: PERMISSION (directional gate, no vectors)
// - Daily: BIAS (direction + strength)
// - Session: FORCE (full vectors + intent)
//
// All engines synchronized with:
// - Defended liquidity anchoring (not ORM)
// - Intent memory for gating (temporal persistence)
// - Real-time safe logic (no future bias)
// - Conditional probability (not additive boosts)
// - Vector persistence (50-bar half-life)
// - HTF gates signals (doesn't inflate CPS)
// - Structural resets (event-driven, not time-based)
// =============================================================================

// =============================================================================
// END OF INDICATOR
// =============================================================================

//@version=6
indicator("HORC v1.0", overlay=true, max_bars_back=500)

INCONCLUSIVE = 0
BUYER = 1
SELLER = -1
DIV_NONE = 0
DIV_PARTIAL = 1
DIV_FULL = 2
ABS_NONE = 0
ABS_INTERNAL = 1
ABS_EXTERNAL = 2
ABS_EXHAUSTION = 3

enable_signals = input.bool(true, "Signals", group="Core")
enable_alerts = input.bool(true, "Alerts", group="Core")
show_table = input.bool(true, "Info", group="Display")
or_window = input.int(60, "OR Minutes", minval=15, maxval=120, group="Core")
conf_thresh = input.float(0.55, "CPS Threshold", minval=0.5, maxval=0.9, step=0.01, group="Core")
enable_intent = input.bool(true, "Intent Memory", group="Intent")
intent_agg_wt = input.float(0.60, "Aggressor Weight", minval=0.0, maxval=1.0, step=0.05, group="Intent")
intent_pass_wt = input.float(0.40, "Passive Weight", minval=0.0, maxval=1.0, step=0.05, group="Intent")
intent_decay = input.float(0.995, "Decay", minval=0.98, maxval=0.999, step=0.001, group="Intent")
enable_htf = input.bool(true, "HTF Gate", group="HTF")
min_htf_align = input.int(2, "Min Alignment", minval=1, maxval=4, group="HTF")
block_compressed = input.bool(false, "Block Compressed", group="Regime")

var float orh = na
var float orl = na
var bool or_formed = false
var int or_end_bar = na
var int current_participant = INCONCLUSIVE
var string w_state = "PRE_OR"
var int move1_bar = na
var int move2_bar = na
var int flip_bar = na
var float move1_price = na
var float move2_price = na
var int expected_dir = INCONCLUSIVE
var int signal_dir = INCONCLUSIVE
var float entry_price = na
var float stop_price = na
var float target_price = na
var int flip_bar_idx = na
var float intent_balance = 0.0
var float intent_mag = 0.0
var int intent_bars = 0
var float def_liq = na
var int htf_M_dir = INCONCLUSIVE
var int htf_W_dir = INCONCLUSIVE
var int coord_align = 0
var bool htf_perm = true
var int div_type = DIV_NONE
var int div_axes = 0
var int abs_type = ABS_NONE
var float conf = 0.0
var float wavelength_bias = 0.0
var int sess_fail_count = 0
var array<float> fail_prices = array.new<float>()
var array<int> fail_bars = array.new<int>()
var array<float> gap_prices = array.new<float>()
var array<bool> gap_filled = array.new<bool>()
var array<int> gap_bars = array.new<int>()

is_new_sess = ta.change(time("D")) != 0
if is_new_sess
    orh := na
    orl := na
    or_formed := false
    or_end_bar := na
    current_participant := INCONCLUSIVE
    w_state := "PRE_OR"
    wavelength_bias *= 0.5
    sess_fail_count := 0

or_mins = or_window
is_regular_session = not na(time(timeframe.period, "0930-1600:23456"))
sess_start = timestamp(year, month, dayofmonth, 9, 30, 0)
or_end = sess_start + or_mins * 60 * 1000
in_or_window = is_regular_session and time >= sess_start and time < or_end and not or_formed

if in_or_window
    orh := na(orh) ? high : math.max(orh, high)
    orl := na(orl) ? low : math.min(orl, low)

if not na(orh) and not na(orl) and time >= or_end and not or_formed
    or_formed := true
    or_end_bar := bar_index

atr_14 = ta.atr(14)
atr_50 = ta.atr(50)
avg_vol = ta.sma(volume, 20)
regime_vol = atr_14 / atr_50
comp_thresh = 0.65
exp_thresh = 1.25
regime_state = regime_vol < comp_thresh ? "COMP" : regime_vol > exp_thresh ? "EXP" : "NORM"
regime_conf_mult = regime_vol < comp_thresh ? 0.85 : regime_vol > exp_thresh ? 1.15 : 1.0
regime_trade = regime_state == "COMP" ? not block_compressed : true

if enable_htf
    htf_M_close = request.security(syminfo.tickerid, "M", close, gaps=barmerge.gaps_off)
    htf_M_open = request.security(syminfo.tickerid, "M", open, gaps=barmerge.gaps_off)
    htf_M_hl2 = request.security(syminfo.tickerid, "M", hl2, gaps=barmerge.gaps_off)
    htf_W_close = request.security(syminfo.tickerid, "W", close, gaps=barmerge.gaps_off)
    htf_W_open = request.security(syminfo.tickerid, "W", open, gaps=barmerge.gaps_off)
    htf_W_hl2 = request.security(syminfo.tickerid, "W", hl2, gaps=barmerge.gaps_off)
    htf_M_body_pos = not na(htf_M_close) and not na(htf_M_hl2) ? (htf_M_close - htf_M_hl2) / atr_14 : 0.0
    htf_W_body_pos = not na(htf_W_close) and not na(htf_W_hl2) ? (htf_W_close - htf_W_hl2) / atr_14 : 0.0
    htf_M_dir := htf_M_body_pos > 0.3 ? BUYER : htf_M_body_pos < -0.3 ? SELLER : INCONCLUSIVE
    htf_W_dir := htf_W_body_pos > 0.3 ? BUYER : htf_W_body_pos < -0.3 ? SELLER : INCONCLUSIVE
    coord_align := 1
    if not na(htf_M_dir) and htf_M_dir == current_participant
        coord_align += 1
    if not na(htf_W_dir) and htf_W_dir == current_participant
        coord_align += 1
    htf_perm := coord_align >= min_htf_align
else
    htf_perm := true
    coord_align := 1

if or_formed and current_participant == INCONCLUSIVE
    buyer_sweep = low < orl
    seller_sweep = high > orh
    if buyer_sweep and not seller_sweep
        current_participant := BUYER
        def_liq := orl
    else if seller_sweep and not buyer_sweep
        current_participant := SELLER
        def_liq := orh
    else if buyer_sweep and seller_sweep
        current_participant := volume > avg_vol * 1.2 and close > open ? BUYER : close < open ? SELLER : INCONCLUSIVE
        def_liq := current_participant == BUYER ? orl : current_participant == SELLER ? orh : na

coord_D = current_participant
vec_D_pass = na(def_liq) or current_participant == INCONCLUSIVE ? 0.0 :     current_participant * (close - def_liq) / atr_14 * math.exp(-(bar_index - or_end_bar) / 50.0)
vec_D_agg = na(def_liq) or current_participant == INCONCLUSIVE ? 0.0 :     current_participant * (volume / avg_vol - 1.0) * math.exp(-(bar_index - or_end_bar) / 50.0)

if enable_intent and not na(vec_D_agg) and not na(vec_D_pass)
    agg_dir = vec_D_agg > 0 ? 1 : vec_D_agg < 0 ? -1 : 0
    pass_dir = vec_D_pass > 0 ? 1 : vec_D_pass < 0 ? -1 : 0
    alignment = agg_dir == pass_dir and agg_dir != 0 ? math.abs(vec_D_agg) : 0.0
    conflict = agg_dir != pass_dir and agg_dir != 0 and pass_dir != 0 ? -math.abs(vec_D_pass) : 0.0
    intent_balance += (alignment * intent_agg_wt + conflict * intent_pass_wt)
    intent_balance *= intent_decay
    x = intent_balance / 3.0
    tanh_approx = x / (1.0 + math.abs(x))
    intent_balance := tanh_approx * 3.0
    intent_mag := math.abs(intent_balance)
    if (intent_balance > 0 and intent_balance[1] > 0) or (intent_balance < 0 and intent_balance[1] < 0)
        intent_bars += 1
    else
        intent_bars := 0

body = math.abs(close - open)
displ = math.max(body, atr_14 * 0.1)
emiss = volume / displ
emiss_sma = ta.sma(emiss, 20)
emiss_norm = emiss / emiss_sma
abs_type := ABS_NONE
near_def = not na(def_liq) and math.abs(close - def_liq) < atr_14 * 0.4
if near_def and enable_intent and not na(vec_D_agg) and not na(vec_D_pass)
    if emiss_norm > 1.5 and math.abs(close - close[1]) < atr_14 * 0.25
        abs_type := ABS_EXHAUSTION
    else if emiss_norm > 1.2 and intent_balance * current_participant > 0
        abs_type := ABS_INTERNAL
    else if emiss_norm > 1.0
        abs_type := ABS_EXTERNAL
    else
        abs_type := ABS_NONE

div_type := DIV_NONE
div_axes := 0
if current_participant != INCONCLUSIVE
    emiss_3 = ta.sma(emiss, 3)
    price_vel = (close - close[3]) / (atr_14 * 3)
    emiss_div = emiss_3 > 1.4 and math.abs(price_vel) < 0.3
    price_div = math.abs(price_vel) > 0.6 and emiss_3 < 0.8
    if emiss_div
        div_axes += 1
    if price_div
        div_axes += 1
    if div_axes > 0 and expected_dir != INCONCLUSIVE and enable_intent
        if intent_balance * expected_dir < 0
            div_axes += 1
    div_type := div_axes >= 2 ? DIV_FULL : div_axes == 1 ? DIV_PARTIAL : DIV_NONE

conf := 0.5
if div_type == DIV_FULL
    conf += 0.12
else if div_type == DIV_PARTIAL
    conf += 0.06
conf *= regime_conf_mult
if enable_intent
    intent_mult = intent_mag > 0.5 ? 1.15 : intent_mag < 0.2 ? 0.85 : 1.0
    conf *= intent_mult
if abs_type == ABS_INTERNAL
    conf *= 1.10
else if abs_type == ABS_EXTERNAL
    conf *= 1.05
else if abs_type == ABS_EXHAUSTION
    conf *= 0.70
conf *= math.max(0.7, 1.0 + wavelength_bias)
conf := math.min(0.95, math.max(0.35, conf))

bool in_fail_zone = false
if array.size(fail_prices) > 0
    for i = 0 to array.size(fail_prices) - 1
        fp = array.get(fail_prices, i)
        if math.abs(close - fp) < atr_14 * 0.5
            in_fail_zone := true
            break
if in_fail_zone and sess_fail_count >= 2
    conf *= 0.75
    wavelength_bias -= 0.1
bool not_repeat = not in_fail_zone

if w_state == "PRE_OR" and or_formed and current_participant != INCONCLUSIVE
    w_state := "PART_ID"

if w_state == "PART_ID"
    move_detected = current_participant == BUYER ? close > def_liq + atr_14 * 0.5 : close < def_liq - atr_14 * 0.5
    if move_detected
        w_state := "MOVE_1"
        move1_bar := bar_index
        move1_price := close

if w_state == "MOVE_1"
    retest = current_participant == BUYER ? low <= def_liq + atr_14 * 0.3 : high >= def_liq - atr_14 * 0.3
    if retest
        w_state := "MOVE_2"
        move2_bar := bar_index
        move2_price := close

if w_state == "MOVE_2"
    if abs_type != ABS_NONE or div_type != DIV_NONE
        flip_detected = (current_participant == BUYER and close < def_liq - atr_14 * 0.2) or 
                       (current_participant == SELLER and close > def_liq + atr_14 * 0.2)
        if flip_detected
            w_state := "FLIP_CONF"
            flip_bar := bar_index
            expected_dir := current_participant == BUYER ? SELLER : BUYER

if w_state == "FLIP_CONF"
    bars_since = bar_index - flip_bar
    if bars_since > 10
        w_state := "FAILED"
        if not na(move2_price)
            array.push(fail_prices, move2_price)
            array.push(fail_bars, move2_bar)
        sess_fail_count += 1
        wavelength_bias -= 0.15
    else
        move3_conf = (expected_dir == BUYER and close > move2_price + atr_14 * 0.5) or 
                     (expected_dir == SELLER and close < move2_price - atr_14 * 0.5)
        if move3_conf
            w_state := "MOVE_3"

intent_allows = true
if enable_intent
    intent_thresh = regime_state == "COMP" ? 0.35 : regime_state == "EXP" ? 0.15 : 0.2
    if expected_dir == BUYER
        intent_allows := intent_balance > intent_thresh
    else if expected_dir == SELLER
        intent_allows := intent_balance < -intent_thresh

htf_allows = htf_perm
valid = w_state == "MOVE_3"
high_conf = conf >= conf_thresh
within_window = not na(flip_bar) and bar_index - flip_bar <= 5 and bar_index >= flip_bar
abs_trade = abs_type != ABS_NONE

buy_signal = valid and high_conf and abs_trade and within_window and expected_dir == BUYER and regime_trade and not_repeat and intent_allows and htf_allows
sell_signal = valid and high_conf and abs_trade and within_window and expected_dir == SELLER and regime_trade and not_repeat and intent_allows and htf_allows

if buy_signal
    signal_dir := BUYER
    entry_price := close
    stop_price := math.min(orl, def_liq - atr_14 * 0.5)
    rr_mult = enable_intent and intent_mag > 0.5 ? 2.5 : 2.0
    target_price := entry_price + (entry_price - stop_price) * rr_mult
    flip_bar_idx := bar_index
    w_state := "COMPLETE"

if sell_signal
    signal_dir := SELLER
    entry_price := close
    stop_price := math.max(orh, def_liq + atr_14 * 0.5)
    rr_mult = enable_intent and intent_mag > 0.5 ? 2.5 : 2.0
    target_price := entry_price - (stop_price - entry_price) * rr_mult
    flip_bar_idx := bar_index
    w_state := "COMPLETE"

if signal_dir != INCONCLUSIVE and not na(entry_price)
    if signal_dir == BUYER
        if high >= target_price
            signal_dir := INCONCLUSIVE
            expected_dir := INCONCLUSIVE
            w_state := "PRE_OR"
        else if low <= stop_price
            signal_dir := INCONCLUSIVE
            expected_dir := INCONCLUSIVE
            w_state := "PRE_OR"
    else if signal_dir == SELLER
        if low <= target_price
            signal_dir := INCONCLUSIVE
            expected_dir := INCONCLUSIVE
            w_state := "PRE_OR"
        else if high >= stop_price
            signal_dir := INCONCLUSIVE
            expected_dir := INCONCLUSIVE
            w_state := "PRE_OR"

exhaustion = abs_type == ABS_EXHAUSTION
bgcolor(or_formed ? color.new(color.blue, 95) : na, title="OR Active")

plotshape(buy_signal and enable_signals, "Long", shape.triangleup, location.belowbar, color.green, size=size.small)
plotshape(sell_signal and enable_signals, "Short", shape.triangledown, location.abovebar, color.red, size=size.small)
plot(or_formed ? orh : na, "ORH", color.blue, 1)
plot(or_formed ? orl : na, "ORL", color.blue, 1)
plot(not na(def_liq) ? def_liq : na, "Defended", color.new(color.blue, 70), 1)

alertcondition(buy_signal and enable_alerts, "HORC Long", "LONG @ {{close}} | CPS: {{plot_0}}")
alertcondition(sell_signal and enable_alerts, "HORC Short", "SHORT @ {{close}} | CPS: {{plot_0}}")
alertcondition(exhaustion and enable_alerts, "Exhaustion", "Exhaustion detected")
alertcondition(div_type == DIV_FULL and enable_alerts, "Divergence", "Full divergence")

if show_table
    var table t = table.new(position.top_right, 2, 8, bgcolor=color.new(color.black, 85), border_width=1)
    if barstate.islast
        table.cell(t, 0, 0, "HORC v1.0", text_color=color.white, text_size=size.normal)
        table.cell(t, 1, 0, regime_state, text_color=color.gray, text_size=size.small)
        table.cell(t, 0, 1, "State", text_color=color.gray, text_size=size.small)
        table.cell(t, 1, 1, w_state, text_color=color.white, text_size=size.small)
        table.cell(t, 0, 2, "Part", text_color=color.gray, text_size=size.small)
        p_txt = current_participant == BUYER ? "BUY" : current_participant == SELLER ? "SELL" : "---"
        table.cell(t, 1, 2, p_txt, text_color=color.white, text_size=size.small)
        table.cell(t, 0, 3, "HTF", text_color=color.gray, text_size=size.small)
        htf_txt = str.tostring(coord_align) + "/4"
        htf_col = coord_align >= 3 ? color.lime : coord_align >= 2 ? color.yellow : color.red
        table.cell(t, 1, 3, htf_txt, text_color=htf_col, text_size=size.small)
        table.cell(t, 0, 4, "Abs", text_color=color.gray, text_size=size.small)
        abs_txt = abs_type == ABS_INTERNAL ? "INT" : abs_type == ABS_EXTERNAL ? "EXT" : abs_type == ABS_EXHAUSTION ? "EXH" : "---"
        table.cell(t, 1, 4, abs_txt, text_color=color.orange, text_size=size.small)
        table.cell(t, 0, 5, "CPS", text_color=color.gray, text_size=size.small)
        cps_txt = str.tostring(math.round(conf * 100)) + "%"
        cps_col = conf >= conf_thresh ? color.lime : color.gray
        table.cell(t, 1, 5, cps_txt, text_color=cps_col, text_size=size.small)
        table.cell(t, 0, 6, "Intent", text_color=color.gray, text_size=size.small)
        int_txt = str.tostring(math.round(intent_balance, 2))
        int_col = intent_balance > 0 ? color.green : intent_balance < 0 ? color.red : color.gray
        table.cell(t, 1, 6, int_txt, text_color=int_col, text_size=size.small)
        table.cell(t, 0, 7, "Status", text_color=color.gray, text_size=size.small)
        stat_txt = signal_dir == BUYER ? "LONG" : signal_dir == SELLER ? "SHORT" : "SCAN"
        stat_col = signal_dir == BUYER ? color.green : signal_dir == SELLER ? color.red : color.gray
        table.cell(t, 1, 7, stat_txt, text_color=stat_col, text_size=size.small)
